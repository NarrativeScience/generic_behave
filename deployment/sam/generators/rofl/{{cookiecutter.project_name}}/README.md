# SAM: {{ cookiecutter.project_name }}

This folder was created automatically by running `sam init --location generators/rofl`. Below is a brief explanation of what we have generated for you:

```bash
.
├── README.MD                   <-- This instructions file
├── event.json                  <-- Example Lambda event payload
├── package                     <-- Source code for a Lambda function
│   └── src/                    <-- Lambda function source code
│   └── package.json            <-- NodeJS dependencies and scripts
│   └── rofl.yml                <-- ROFL file to modify
├── template.yml                <-- SAM template to modify
```

You mainly just need to make changes to the ROFL file [`package/rofl.yml`](package/rofl.yml) and the Lambda function parameters in [`package/template.yml`](package/template.yml). Unless you're trying to add a new task type, you don't need to interact with the actual [ROFL library](../../../../rofl).

## Requirements

* AWS CLI already configured with Administrator permission
* [NodeJS 8.10+ installed](https://nodejs.org/en/download/)
* [Docker installed](https://www.docker.com/community-edition)

## Setup process

### Local development

When you want to test it out, install and build the package:
```bash
sam build
```
...then invoke the function locally using a local sample Lambda event payload:
```bash
sam local invoke --event event.json
```

The SAM CLI is used to emulate Lambda and uses our `template.yml` to understand how to bootstrap this environment (runtime, where the source code is, etc.)

## Packaging and deployment

__First, run `./build.sh`__. This will package the Lambda function, upload the artifact to S3, and generate a CloudFormation template at `/deployment/cf_templates/nested-stacks/rofl-{{ cookiecutter.project_name }}.yml`.

Second, to deploy the stack, you need to __add the nested stack as a resource in the main `talos-application.yml` CF template__ so it gets picked up in our normal CI/CD pipeline. For example:
```yaml
MyNewSAMStack:
  Type: AWS::CloudFormation::Stack
  Properties:
    TemplateURL:
      !Join
        - "/"
        - - https://s3.amazonaws.com/cf-templates-231405699240
          - !Join
              - "-"
              - - !Ref Environment
                - !Ref Platform
                - !Ref Function
          - nested-stacks
          - rofl-{{ cookiecutter.project_name }}.yml
    Parameters:
      Environment: !Ref Environment
      Platform: !Ref Platform
      Function: !Ref Function
    TimeoutInMinutes: 60
    Tags:
      - Key: Environment
        Value: !Ref Environment
      - Key: Platform
        Value: !Ref Platform
      - Key: Function
        Value: !Ref Function
```

### What happens under the hood

When you run `./build.sh`, the SAM CLI will first build the code package. It uses the `CodeUri` property to know where to look up for both application and dependencies.

```yaml
...
    ROFLFunction:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: package/
            ...
```

It will create a new temporary folder, copy the source code and dependency definition file (`package.json`, etc.), install dependencies, then ZIP the folder.

Next, it will upload the packaged artifact to S3 and generate a new template file. This new template file now has a reference to the S3 path of the artifact instead of a local file path. We store these Lambda package artifacts in `s3://{{ cookiecutter.s3_bucket }}`. The new template will be outputted to `/deployment/cf_templates/nested-stacks/rofl-{{ cookiecutter.project_name }}.yml` so we can include it in the main `talos-application.yml` CloudFormation template.

> **See [Serverless Application Model (SAM) HOWTO Guide](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-quick-start.html) for more details.**

## Fetch, tail, and filter Lambda function logs

To simplify troubleshooting, SAM CLI has a command called `sam logs`. `sam logs` lets you fetch logs generated by your Lambda function from the command line. In addition to printing the logs on the terminal, this command has several nifty features to help you quickly find the bug.

**NOTE**: This command works for all AWS Lambda functions; not just the ones you deploy using SAM.

```bash
sam logs \
    -n ROFLFunction \
    --stack-name <stack name> \
    --tail
```

You can find more information and examples about filtering Lambda function logs in the [SAM CLI Documentation](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-logging.html).

## Cleanup

In order to delete our Serverless Application recently deployed you can use the following AWS CLI Command:

```bash
aws cloudformation delete-stack --stack-name <stack name>
```

## Bringing to the next level

Here are a few things you can try to get more acquainted with building serverless applications using SAM:

### Learn how SAM Build can help you with dependencies

* Change `package/src/handler.js`
* Build the project with `sam build [--use-container]`
* Invoke with `sam local invoke ROFLFunction --event event.json`

### Step-through debugging

* **[Enable step-through debugging docs for supported runtimes]((https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-using-debugging.html))**

## Appendix

### Building the project

[AWS Lambda requires a flat folder](https://docs.aws.amazon.com/lambda/latest/dg/nodejs-create-deployment-pkg.html) with the application as well as its dependencies in a node_modules folder. When you make changes to your source code or dependency manifest,
run the following command to build your project local testing and deployment:

```bash
sam build
```

If your dependencies contain native modules that need to be compiled specifically for the operating system running on AWS Lambda, use this command to build inside a Lambda-like Docker container instead:
```bash
sam build --use-container
```

By default, this command writes built artifacts to `.aws-sam/build` folder.
